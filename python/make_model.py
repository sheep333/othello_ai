# -*- coding: utf-8 -*-
"""myothello_machine_learning.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OyLKgY7ZlNjgLmBUkP7IeIyHBjfE1hC_
"""

#!/usr/bin/env python
# coding=utf-8
# 
# 0 : none
# 1 : black
# 2 : white
# 

import sys
import numpy as np
import chainer
from chainer import cuda, Function, gradient_check, report, training, utils, Variable
from chainer import datasets, iterators, optimizers, serializers
from chainer import Link, Chain, ChainList
import chainer.functions as F
import chainer.links as L
from chainer.training import extensions
from google.colab import files

gCol = ('1','2','3','4','5','6','7','8')
gRow = ('1','2','3','4','5','6','7','8')

#分類器を使って64パターンの出力に変換
class MLP(Chain):
    def __init__(self):
        super(MLP, self).__init__(
                #隠れ層等を200にしたりしても精度上がるかも。時間があったら試したい。
                l1=L.Linear(64, 100),
                l2=L.Linear(100, 100),
                l3=L.Linear(100, 65),
        )

    def __call__(self, x):
        h1 = F.relu(self.l1(x))
        h2 = F.relu(self.l2(h1))
        y = self.l3(h2)
        return y

class Classifier(Chain):
    def __init__(self, predictor):
        super(Classifier, self).__init__(predictor=predictor)

    def __call__(self, x, t):
        y = self.predictor(x)
        loss = F.softmax_cross_entropy(y, t)
        accuracy = F.accuracy(y, t)
        report({'loss': loss, 'accuracy': accuracy}, self)
        return loss


      
#-- 必要な関数を定義　--#

def conv_pos_to_num(position):
  #左上を1として右に増加していくボードとする
  #[1, 2, 3, 4, 5, 6, 7, 8]
  #[9,10,11,12,13,14,15,16]
  #[................,63,64]
  try:
    col_num = gCol.index(position[0])+1
    row_num = int(position[1])
    pos_num = (row_num-1)*8 + col_num
  except:
    print(position[0])
    print(line_cnt)
    pos_num = 0
    
  return pos_num

def conv_num_to_pos(pos_num):
    pos = []
    row,col= divmod(pos_num,8)
    if col == 0:
      pos.append(gcol[7])
      pos.append(row)
    else:
      pos.append(gCol[col-1])    
      pos.append(str(row+1))
      
    return pos

#-- Main処理 --#
record_X = []    # MLP input (board list -> white_win)
record_y = []    # MLP output(class(0-64) list -> white_win)
record_white_X = []    # MLP input (board list -> white_win)
record_white_y = []    # MLP output(class(0-64) list -> white_win)
record_black_X = []    # MLP input (board list -> black_win)
record_black_y = []    # MLP output(class(0-64) -> black_win)
test_X = []
test_y = []
test_white_X = []
test_white_y = []
test_black_X = []
test_black_y = []

#-- レコードを読み込んで、棋譜とそれに対応する正解(石を置くべき場所)データを作成する --#

f = open(file, "r")
line_cnt = 1
for line in f:
  board = []
  position = []
  line_list = line.split(" ")
  #8*8のボードにする
  board = [line_list[i:i+8] for i in range(0,63,8)]
  position = line_list[-4:-2]  

  if line_cnt <= 1200000:
    #データ追加していく
    #record_X.append(board)
    #record_y.append(conv_pos_to_num(position))
    if(line_list[-2] =="W"):
      record_white_X.append(board)
      record_white_y.append(conv_pos_to_num(position))
    elif(line_list[-2] == "B"):
      record_black_X.append(board)
      record_black_y.append(conv_pos_to_num(position))
    else:
      print("データエラーです")
  elif(line_cnt <= 1260000):
    test_X.append(board)
    test_y.append(conv_pos_to_num(position))
    if(line_list[-2] =="W"):
      test_white_X.append(board)
      test_white_y.append(conv_pos_to_num(position))
    elif(line_list[-2] == "B"):
      test_black_X.append(board)
      test_black_y.append(conv_pos_to_num(position))
    else:
      print("データエラーです")
  else:
    break;
  line_cnt += 1


#-- モデルの作成と学習 --#

def make_model(record_X,record_y,mode):
    X = np.array(record_X, dtype=np.float32) # 全ゲームの棋譜リスト
    y = np.array(record_y, dtype=np.int32)   # 全ゲームの石の置き場の正解リスト
    
    train = datasets.TupleDataset(X, y)
    train_iter = iterators.SerialIterator(train, batch_size=100)

    model = Classifier(MLP()) #MLPという手法で学習
    #ここもSDGじゃなくてAdamとかに変えたら精度あがるかも。時間があったら試したい。
    optimizer = optimizers.SGD()
    optimizer.setup(model)
    
    updater = training.StandardUpdater(train_iter, optimizer)
    trainer = training.Trainer(updater, (150, 'epoch'), out='result')
    trainer.extend(extensions.PlotReport(['main/accuracy', 'val/main/accuracy'], x_key='epoch', file_name='accuracy.png', trigger=(1,'epoch')))
    trainer.run()
    
    if mode == "black":
        serializers.save_npz('black.npz', model)
        files.download('black.npz')
    elif mode == "white":
        serializers.save_npz('white.npz', model)
        files.download('white.npz')
    else:
        serializers.save_npz('model.npz', model)
        files.download('model.npz')
        

#それぞれの実行処理
make_model(record_black_X,record_black_y,"black")
make_model(record_white_X,record_white_y,"white")
